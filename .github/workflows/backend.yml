name: Backend CI/CD

on:
  push:
    branches: [main]
    paths:
      - "backend-disc/**"
  pull_request:
    branches: [main]
    paths:
      - "backend-disc/**"

jobs:
  test:
    runs-on: ubuntu-latest
    env:
      DB_NAME: ${{ secrets.DB_NAME }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      API_SECRET_KEY: ${{ secrets.API_SECRET_KEY }}

    steps:
      - uses: actions/checkout@v3

      - name: Start SQL Server container (uses repo secret)
        shell: bash
        run: |
          docker run -e 'ACCEPT_EULA=Y' -e "SA_PASSWORD=${{ secrets.DB_PASSWORD }}" -p 1433:1433 --name disc-mssql -d mcr.microsoft.com/mssql/server:2022-latest
          for i in {1..60}; do
            if docker logs disc-mssql 2>&1 | grep -q "SQL Server is now ready for client connections."; then
              echo "SQL Server ready"; exit 0;
            fi
            echo "Waiting for SQL Server... ($i/60)"; sleep 2;
          done
          echo "SQL Server failed to start"; docker logs disc-mssql; exit 1

      - name: Create .env file
        run: |
          mkdir -p backend-disc
          cat > backend-disc/.env <<'EOF'
          DB_USER=sa
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_HOST=localhost
          DB_PORT=1433
          ConnectionStrings__DefaultConnection=Server=localhost,1433;Database=${{ secrets.DB_NAME }};User Id=sa;Password=${{ secrets.DB_PASSWORD }};TrustServerCertificate=True;
          API_SECRET_KEY=${{ secrets.API_SECRET_KEY }}
          ASPNETCORE_ENVIRONMENT=Development
          EOF

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: "8.0.x"

      - name: Restore dependencies
        working-directory: backend-disc
        run: dotnet restore

      - name: Build
        working-directory: backend-disc
        run: dotnet build --no-restore --configuration Release

      - name: Start API
        working-directory: backend-disc
        env:
          ConnectionStrings__DefaultConnection: "Server=localhost,1433;Database=${{ secrets.DB_NAME }};User Id=sa;Password=${{ secrets.DB_PASSWORD }};TrustServerCertificate=True;"
          API_SECRET_KEY: ${{ secrets.API_SECRET_KEY }}
          ASPNETCORE_URLS: http://+:5000
          ASPNETCORE_ENVIRONMENT: Development
        run: |
          dotnet run --project backend-disc.csproj --configuration Release --urls "http://0.0.0.0:5000" &
          sleep 12

      - name: Install Newman
        run: npm install -g newman

      - name: Run Postman tests
        working-directory: backend-disc
        continue-on-error: true
        run: |
          newman run Disc-api-test.postman_collection.json --environment postman-env.json --reporters cli,json --reporter-json-export test-results.json || true

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: postman-test-results
          path: backend-disc/test-results.json

      - name: Comment PR with test results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const path = './backend-disc/test-results.json';
            if (!fs.existsSync(path)) {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: 'Postman test results not found.'
              });
              return;
            }
            const results = JSON.parse(fs.readFileSync(path, 'utf8'));
            const total = results.run?.stats?.tests?.total ?? 0;
            const failed = results.run?.stats?.tests?.failed ?? 0;
            const passed = total - failed;
            const duration = results.run?.timings?.completed ?? 'n/a';
            const comment = `## Postman Test Results\n\n✅ Passed: ${passed}\n❌ Failed: ${failed}\n⏱️ Duration: ${duration}ms`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
